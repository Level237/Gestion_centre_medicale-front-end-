(function () {
  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  (self["webpackChunkcliniva"] = self["webpackChunkcliniva"] || []).push([["default-node_modules_angular_material___ivy_ngcc___fesm2015_snack-bar_js"], {
    /***/
    77001:
    /*!***************************************************************************!*\
      !*** ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/snack-bar.js ***!
      \***************************************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "MAT_SNACK_BAR_DATA": function MAT_SNACK_BAR_DATA() {
          return (
            /* binding */
            _MAT_SNACK_BAR_DATA
          );
        },

        /* harmony export */
        "MAT_SNACK_BAR_DEFAULT_OPTIONS": function MAT_SNACK_BAR_DEFAULT_OPTIONS() {
          return (
            /* binding */
            _MAT_SNACK_BAR_DEFAULT_OPTIONS
          );
        },

        /* harmony export */
        "MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY": function MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY() {
          return (
            /* binding */
            _MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY
          );
        },

        /* harmony export */
        "MatSnackBar": function MatSnackBar() {
          return (
            /* binding */
            _MatSnackBar
          );
        },

        /* harmony export */
        "MatSnackBarConfig": function MatSnackBarConfig() {
          return (
            /* binding */
            _MatSnackBarConfig
          );
        },

        /* harmony export */
        "MatSnackBarContainer": function MatSnackBarContainer() {
          return (
            /* binding */
            _MatSnackBarContainer
          );
        },

        /* harmony export */
        "MatSnackBarModule": function MatSnackBarModule() {
          return (
            /* binding */
            _MatSnackBarModule
          );
        },

        /* harmony export */
        "MatSnackBarRef": function MatSnackBarRef() {
          return (
            /* binding */
            _MatSnackBarRef
          );
        },

        /* harmony export */
        "SimpleSnackBar": function SimpleSnackBar() {
          return (
            /* binding */
            _SimpleSnackBar
          );
        },

        /* harmony export */
        "matSnackBarAnimations": function matSnackBarAnimations() {
          return (
            /* binding */
            _matSnackBarAnimations
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
      /*! @angular/cdk/overlay */
      58203);
      /* harmony import */


      var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @angular/cdk/portal */
      87636);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/common */
      38583);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      37716);
      /* harmony import */


      var _angular_material_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
      /*! @angular/material/core */
      5015);
      /* harmony import */


      var _angular_material_button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/material/button */
      51095);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! rxjs */
      47762);
      /* harmony import */


      var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! @angular/cdk/platform */
      80521);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! rxjs/operators */
      74294);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
      /*! rxjs/operators */
      25755);
      /* harmony import */


      var _angular_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/animations */
      17238);
      /* harmony import */


      var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
      /*! @angular/cdk/a11y */
      19238);
      /* harmony import */


      var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
      /*! @angular/cdk/layout */
      65072);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Injection token that can be used to access the data that was passed in to a snack bar. */


      function SimpleSnackBar_div_2_Template(rf, ctx) {
        if (rf & 1) {
          var _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "button", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function SimpleSnackBar_div_2_Template_button_click_1_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r1.action();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r0.data.action);
        }
      }

      function MatSnackBarContainer_ng_template_1_Template(rf, ctx) {}

      var _MAT_SNACK_BAR_DATA = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('MatSnackBarData');
      /**
       * Configuration used when opening a snack-bar.
       */


      var _MatSnackBarConfig = function _MatSnackBarConfig() {
        _classCallCheck(this, _MatSnackBarConfig);

        /** The politeness level for the MatAriaLiveAnnouncer announcement. */
        this.politeness = 'assertive';
        /**
         * Message to be announced by the LiveAnnouncer. When opening a snackbar without a custom
         * component or template, the announcement message will default to the specified message.
         */

        this.announcementMessage = '';
        /** The length of time in milliseconds to wait before automatically dismissing the snack bar. */

        this.duration = 0;
        /** Data being injected into the child component. */

        this.data = null;
        /** The horizontal position to place the snack bar. */

        this.horizontalPosition = 'center';
        /** The vertical position to place the snack bar. */

        this.verticalPosition = 'bottom';
      };
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Maximum amount of milliseconds that can be passed into setTimeout. */


      var MAX_TIMEOUT = Math.pow(2, 31) - 1;
      /**
       * Reference to a snack bar dispatched from the snack bar service.
       */

      var _MatSnackBarRef = /*#__PURE__*/function () {
        function _MatSnackBarRef(containerInstance, _overlayRef) {
          var _this = this;

          _classCallCheck(this, _MatSnackBarRef);

          this._overlayRef = _overlayRef;
          /** Subject for notifying the user that the snack bar has been dismissed. */

          this._afterDismissed = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Subject for notifying the user that the snack bar has opened and appeared. */

          this._afterOpened = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Subject for notifying the user that the snack bar action was called. */

          this._onAction = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Whether the snack bar was dismissed using the action button. */

          this._dismissedByAction = false;
          this.containerInstance = containerInstance; // Dismiss snackbar on action.

          this.onAction().subscribe(function () {
            return _this.dismiss();
          });

          containerInstance._onExit.subscribe(function () {
            return _this._finishDismiss();
          });
        }
        /** Dismisses the snack bar. */


        _createClass(_MatSnackBarRef, [{
          key: "dismiss",
          value: function dismiss() {
            if (!this._afterDismissed.closed) {
              this.containerInstance.exit();
            }

            clearTimeout(this._durationTimeoutId);
          }
          /** Marks the snackbar action clicked. */

        }, {
          key: "dismissWithAction",
          value: function dismissWithAction() {
            if (!this._onAction.closed) {
              this._dismissedByAction = true;

              this._onAction.next();

              this._onAction.complete();
            }

            clearTimeout(this._durationTimeoutId);
          }
          /**
           * Marks the snackbar action clicked.
           * @deprecated Use `dismissWithAction` instead.
           * @breaking-change 8.0.0
           */

        }, {
          key: "closeWithAction",
          value: function closeWithAction() {
            this.dismissWithAction();
          }
          /** Dismisses the snack bar after some duration */

        }, {
          key: "_dismissAfter",
          value: function _dismissAfter(duration) {
            var _this2 = this;

            // Note that we need to cap the duration to the maximum value for setTimeout, because
            // it'll revert to 1 if somebody passes in something greater (e.g. `Infinity`). See #17234.
            this._durationTimeoutId = setTimeout(function () {
              return _this2.dismiss();
            }, Math.min(duration, MAX_TIMEOUT));
          }
          /** Marks the snackbar as opened */

        }, {
          key: "_open",
          value: function _open() {
            if (!this._afterOpened.closed) {
              this._afterOpened.next();

              this._afterOpened.complete();
            }
          }
          /** Cleans up the DOM after closing. */

        }, {
          key: "_finishDismiss",
          value: function _finishDismiss() {
            this._overlayRef.dispose();

            if (!this._onAction.closed) {
              this._onAction.complete();
            }

            this._afterDismissed.next({
              dismissedByAction: this._dismissedByAction
            });

            this._afterDismissed.complete();

            this._dismissedByAction = false;
          }
          /** Gets an observable that is notified when the snack bar is finished closing. */

        }, {
          key: "afterDismissed",
          value: function afterDismissed() {
            return this._afterDismissed;
          }
          /** Gets an observable that is notified when the snack bar has opened and appeared. */

        }, {
          key: "afterOpened",
          value: function afterOpened() {
            return this.containerInstance._onEnter;
          }
          /** Gets an observable that is notified when the snack bar action is called. */

        }, {
          key: "onAction",
          value: function onAction() {
            return this._onAction;
          }
        }]);

        return _MatSnackBarRef;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * A component used to open as the default snack bar, matching material spec.
       * This should only be used internally by the snack bar service.
       */


      var _SimpleSnackBar = /*#__PURE__*/function () {
        function _SimpleSnackBar(snackBarRef, data) {
          _classCallCheck(this, _SimpleSnackBar);

          this.snackBarRef = snackBarRef;
          this.data = data;
        }
        /** Performs the action on the snack bar. */


        _createClass(_SimpleSnackBar, [{
          key: "action",
          value: function action() {
            this.snackBarRef.dismissWithAction();
          }
          /** If the action button should be shown. */

        }, {
          key: "hasAction",
          get: function get() {
            return !!this.data.action;
          }
        }]);

        return _SimpleSnackBar;
      }();

      _SimpleSnackBar.ɵfac = function SimpleSnackBar_Factory(t) {
        return new (t || _SimpleSnackBar)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_MatSnackBarRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_MAT_SNACK_BAR_DATA));
      };

      _SimpleSnackBar.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: _SimpleSnackBar,
        selectors: [["simple-snack-bar"]],
        hostAttrs: [1, "mat-simple-snackbar"],
        decls: 3,
        vars: 2,
        consts: [["class", "mat-simple-snackbar-action", 4, "ngIf"], [1, "mat-simple-snackbar-action"], ["mat-button", "", 3, "click"]],
        template: function SimpleSnackBar_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span");

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, SimpleSnackBar_div_2_Template, 3, 1, "div", 0);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx.data.message);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.hasAction);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_2__.NgIf, _angular_material_button__WEBPACK_IMPORTED_MODULE_3__.MatButton],
        styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}\n"],
        encapsulation: 2,
        changeDetection: 0
      });

      _SimpleSnackBar.ctorParameters = function () {
        return [{
          type: _MatSnackBarRef
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_MAT_SNACK_BAR_DATA]
          }]
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_SimpleSnackBar, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'simple-snack-bar',
            template: "<span>{{data.message}}</span>\n<div class=\"mat-simple-snackbar-action\"  *ngIf=\"hasAction\">\n  <button mat-button (click)=\"action()\">{{data.action}}</button>\n</div>\n",
            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None,
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            host: {
              'class': 'mat-simple-snackbar'
            },
            styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}\n"]
          }]
        }], function () {
          return [{
            type: _MatSnackBarRef
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_MAT_SNACK_BAR_DATA]
            }]
          }];
        }, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Animations used by the Material snack bar.
       * @docs-private
       */


      var _matSnackBarAnimations = {
        /** Animation that shows and hides a snack bar. */
        snackBarState: (0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.trigger)('state', [(0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.state)('void, hidden', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.style)({
          transform: 'scale(0.8)',
          opacity: 0
        })), (0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.state)('visible', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.style)({
          transform: 'scale(1)',
          opacity: 1
        })), (0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.transition)('* => visible', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.animate)('150ms cubic-bezier(0, 0, 0.2, 1)')), (0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.transition)('* => void, * => hidden', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.animate)('75ms cubic-bezier(0.4, 0.0, 1, 1)', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_4__.style)({
          opacity: 0
        })))])
      };
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Internal component that wraps user-provided snack bar content.
       * @docs-private
       */

      var _MatSnackBarContainer = /*#__PURE__*/function (_angular_cdk_portal__) {
        _inherits(_MatSnackBarContainer, _angular_cdk_portal__);

        var _super = _createSuper(_MatSnackBarContainer);

        function _MatSnackBarContainer(_ngZone, _elementRef, _changeDetectorRef, _platform,
        /** The snack bar configuration. */
        snackBarConfig) {
          var _this3;

          _classCallCheck(this, _MatSnackBarContainer);

          _this3 = _super.call(this);
          _this3._ngZone = _ngZone;
          _this3._elementRef = _elementRef;
          _this3._changeDetectorRef = _changeDetectorRef;
          _this3._platform = _platform;
          _this3.snackBarConfig = snackBarConfig;
          /** The number of milliseconds to wait before announcing the snack bar's content. */

          _this3._announceDelay = 150;
          /** Whether the component has been destroyed. */

          _this3._destroyed = false;
          /** Subject for notifying that the snack bar has announced to screen readers. */

          _this3._onAnnounce = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Subject for notifying that the snack bar has exited from view. */

          _this3._onExit = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Subject for notifying that the snack bar has finished entering the view. */

          _this3._onEnter = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** The state of the snack bar animations. */

          _this3._animationState = 'void';
          /**
           * Attaches a DOM portal to the snack bar container.
           * @deprecated To be turned into a method.
           * @breaking-change 10.0.0
           */

          _this3.attachDomPortal = function (portal) {
            _this3._assertNotAttached();

            _this3._applySnackBarClasses();

            return _this3._portalOutlet.attachDomPortal(portal);
          }; // Use aria-live rather than a live role like 'alert' or 'status'
          // because NVDA and JAWS have show inconsistent behavior with live roles.


          if (snackBarConfig.politeness === 'assertive' && !snackBarConfig.announcementMessage) {
            _this3._live = 'assertive';
          } else if (snackBarConfig.politeness === 'off') {
            _this3._live = 'off';
          } else {
            _this3._live = 'polite';
          } // Only set role for Firefox. Set role based on aria-live because setting role="alert" implies
          // aria-live="assertive" which may cause issues if aria-live is set to "polite" above.


          if (_this3._platform.FIREFOX) {
            if (_this3._live === 'polite') {
              _this3._role = 'status';
            }

            if (_this3._live === 'assertive') {
              _this3._role = 'alert';
            }
          }

          return _this3;
        }
        /** Attach a component portal as content to this snack bar container. */


        _createClass(_MatSnackBarContainer, [{
          key: "attachComponentPortal",
          value: function attachComponentPortal(portal) {
            this._assertNotAttached();

            this._applySnackBarClasses();

            return this._portalOutlet.attachComponentPortal(portal);
          }
          /** Attach a template portal as content to this snack bar container. */

        }, {
          key: "attachTemplatePortal",
          value: function attachTemplatePortal(portal) {
            this._assertNotAttached();

            this._applySnackBarClasses();

            return this._portalOutlet.attachTemplatePortal(portal);
          }
          /** Handle end of animations, updating the state of the snackbar. */

        }, {
          key: "onAnimationEnd",
          value: function onAnimationEnd(event) {
            var fromState = event.fromState,
                toState = event.toState;

            if (toState === 'void' && fromState !== 'void' || toState === 'hidden') {
              this._completeExit();
            }

            if (toState === 'visible') {
              // Note: we shouldn't use `this` inside the zone callback,
              // because it can cause a memory leak.
              var onEnter = this._onEnter;

              this._ngZone.run(function () {
                onEnter.next();
                onEnter.complete();
              });
            }
          }
          /** Begin animation of snack bar entrance into view. */

        }, {
          key: "enter",
          value: function enter() {
            if (!this._destroyed) {
              this._animationState = 'visible';

              this._changeDetectorRef.detectChanges();

              this._screenReaderAnnounce();
            }
          }
          /** Begin animation of the snack bar exiting from view. */

        }, {
          key: "exit",
          value: function exit() {
            // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case
            // where multiple snack bars are opened in quick succession (e.g. two consecutive calls to
            // `MatSnackBar.open`).
            this._animationState = 'hidden'; // Mark this element with an 'exit' attribute to indicate that the snackbar has
            // been dismissed and will soon be removed from the DOM. This is used by the snackbar
            // test harness.

            this._elementRef.nativeElement.setAttribute('mat-exit', ''); // If the snack bar hasn't been announced by the time it exits it wouldn't have been open
            // long enough to visually read it either, so clear the timeout for announcing.


            clearTimeout(this._announceTimeoutId);
            return this._onExit;
          }
          /** Makes sure the exit callbacks have been invoked when the element is destroyed. */

        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this._destroyed = true;

            this._completeExit();
          }
          /**
           * Waits for the zone to settle before removing the element. Helps prevent
           * errors where we end up removing an element which is in the middle of an animation.
           */

        }, {
          key: "_completeExit",
          value: function _completeExit() {
            var _this4 = this;

            this._ngZone.onMicrotaskEmpty.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.take)(1)).subscribe(function () {
              _this4._onExit.next();

              _this4._onExit.complete();
            });
          }
          /** Applies the various positioning and user-configured CSS classes to the snack bar. */

        }, {
          key: "_applySnackBarClasses",
          value: function _applySnackBarClasses() {
            var element = this._elementRef.nativeElement;
            var panelClasses = this.snackBarConfig.panelClass;

            if (panelClasses) {
              if (Array.isArray(panelClasses)) {
                // Note that we can't use a spread here, because IE doesn't support multiple arguments.
                panelClasses.forEach(function (cssClass) {
                  return element.classList.add(cssClass);
                });
              } else {
                element.classList.add(panelClasses);
              }
            }

            if (this.snackBarConfig.horizontalPosition === 'center') {
              element.classList.add('mat-snack-bar-center');
            }

            if (this.snackBarConfig.verticalPosition === 'top') {
              element.classList.add('mat-snack-bar-top');
            }
          }
          /** Asserts that no content is already attached to the container. */

        }, {
          key: "_assertNotAttached",
          value: function _assertNotAttached() {
            if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('Attempting to attach snack bar content after content is already attached');
            }
          }
          /**
           * Starts a timeout to move the snack bar content to the live region so screen readers will
           * announce it.
           */

        }, {
          key: "_screenReaderAnnounce",
          value: function _screenReaderAnnounce() {
            var _this5 = this;

            if (!this._announceTimeoutId) {
              this._ngZone.runOutsideAngular(function () {
                _this5._announceTimeoutId = setTimeout(function () {
                  var inertElement = _this5._elementRef.nativeElement.querySelector('[aria-hidden]');

                  var liveElement = _this5._elementRef.nativeElement.querySelector('[aria-live]');

                  if (inertElement && liveElement) {
                    // If an element in the snack bar content is focused before being moved
                    // track it and restore focus after moving to the live region.
                    var focusedElement = null;

                    if (_this5._platform.isBrowser && document.activeElement instanceof HTMLElement && inertElement.contains(document.activeElement)) {
                      focusedElement = document.activeElement;
                    }

                    inertElement.removeAttribute('aria-hidden');
                    liveElement.appendChild(inertElement);
                    focusedElement === null || focusedElement === void 0 ? void 0 : focusedElement.focus();

                    _this5._onAnnounce.next();

                    _this5._onAnnounce.complete();
                  }
                }, _this5._announceDelay);
              });
            }
          }
        }]);

        return _MatSnackBarContainer;
      }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.BasePortalOutlet);

      _MatSnackBarContainer.ɵfac = function MatSnackBarContainer_Factory(t) {
        return new (t || _MatSnackBarContainer)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_MatSnackBarConfig));
      };

      _MatSnackBarContainer.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: _MatSnackBarContainer,
        selectors: [["snack-bar-container"]],
        viewQuery: function MatSnackBarContainer_Query(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.CdkPortalOutlet, 7);
          }

          if (rf & 2) {
            var _t;

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._portalOutlet = _t.first);
          }
        },
        hostAttrs: [1, "mat-snack-bar-container"],
        hostVars: 1,
        hostBindings: function MatSnackBarContainer_HostBindings(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsyntheticHostListener"]("@state.done", function MatSnackBarContainer_animation_state_done_HostBindingHandler($event) {
              return ctx.onAnimationEnd($event);
            });
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsyntheticHostProperty"]("@state", ctx._animationState);
          }
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
        decls: 3,
        vars: 2,
        consts: [["aria-hidden", "true"], ["cdkPortalOutlet", ""]],
        template: function MatSnackBarContainer_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, MatSnackBarContainer_ng_template_1_Template, 0, 0, "ng-template", 1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](2, "div");
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-live", ctx._live)("role", ctx._role);
          }
        },
        directives: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.CdkPortalOutlet],
        styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"],
        encapsulation: 2,
        data: {
          animation: [_matSnackBarAnimations.snackBarState]
        }
      });

      _MatSnackBarContainer.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
        }, {
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__.Platform
        }, {
          type: _MatSnackBarConfig
        }];
      };

      _MatSnackBarContainer.propDecorators = {
        _portalOutlet: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
          args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.CdkPortalOutlet, {
            "static": true
          }]
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_MatSnackBarContainer, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'snack-bar-container',
            template: "<!-- Initially holds the snack bar content, will be empty after announcing to screen readers. -->\n<div aria-hidden=\"true\">\n  <ng-template cdkPortalOutlet></ng-template>\n</div>\n\n<!-- Will receive the snack bar content from the non-live div, move will happen a short delay after opening -->\n<div [attr.aria-live]=\"_live\" [attr.role]=\"_role\"></div>\n",
            // In Ivy embedded views will be change detected from their declaration place, rather than
            // where they were stamped out. This means that we can't have the snack bar container be OnPush,
            // because it might cause snack bars that were opened from a template not to be out of date.
            // tslint:disable-next-line:validate-decorators
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default,
            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None,
            animations: [_matSnackBarAnimations.snackBarState],
            host: {
              'class': 'mat-snack-bar-container',
              '[@state]': '_animationState',
              '(@state.done)': 'onAnimationEnd($event)'
            },
            styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"]
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
          }, {
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__.Platform
          }, {
            type: _MatSnackBarConfig
          }];
        }, {
          _portalOutlet: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
            args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.CdkPortalOutlet, {
              "static": true
            }]
          }]
        });
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var _MatSnackBarModule = function _MatSnackBarModule() {
        _classCallCheck(this, _MatSnackBarModule);
      };

      _MatSnackBarModule.ɵfac = function MatSnackBarModule_Factory(t) {
        return new (t || _MatSnackBarModule)();
      };

      _MatSnackBarModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
        type: _MatSnackBarModule
      });
      _MatSnackBarModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
        imports: [[_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_8__.OverlayModule, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.PortalModule, _angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, _angular_material_button__WEBPACK_IMPORTED_MODULE_3__.MatButtonModule, _angular_material_core__WEBPACK_IMPORTED_MODULE_9__.MatCommonModule], _angular_material_core__WEBPACK_IMPORTED_MODULE_9__.MatCommonModule]
      });

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_MatSnackBarModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
          args: [{
            imports: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_8__.OverlayModule, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.PortalModule, _angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, _angular_material_button__WEBPACK_IMPORTED_MODULE_3__.MatButtonModule, _angular_material_core__WEBPACK_IMPORTED_MODULE_9__.MatCommonModule],
            exports: [_MatSnackBarContainer, _angular_material_core__WEBPACK_IMPORTED_MODULE_9__.MatCommonModule],
            declarations: [_MatSnackBarContainer, _SimpleSnackBar],
            entryComponents: [_MatSnackBarContainer, _SimpleSnackBar]
          }]
        }], null, null);
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_MatSnackBarModule, {
          declarations: function declarations() {
            return [_MatSnackBarContainer, _SimpleSnackBar];
          },
          imports: function imports() {
            return [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_8__.OverlayModule, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.PortalModule, _angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, _angular_material_button__WEBPACK_IMPORTED_MODULE_3__.MatButtonModule, _angular_material_core__WEBPACK_IMPORTED_MODULE_9__.MatCommonModule];
          },
          exports: function exports() {
            return [_MatSnackBarContainer, _angular_material_core__WEBPACK_IMPORTED_MODULE_9__.MatCommonModule];
          }
        });
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Injection token that can be used to specify default snack bar. */


      var _MAT_SNACK_BAR_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('mat-snack-bar-default-options', {
        providedIn: 'root',
        factory: _MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY
      });
      /** @docs-private */


      function _MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY() {
        return new _MatSnackBarConfig();
      }
      /**
       * Service to dispatch Material Design snack bar messages.
       */


      var _MatSnackBar = /*#__PURE__*/function () {
        function _MatSnackBar(_overlay, _live, _injector, _breakpointObserver, _parentSnackBar, _defaultConfig) {
          _classCallCheck(this, _MatSnackBar);

          this._overlay = _overlay;
          this._live = _live;
          this._injector = _injector;
          this._breakpointObserver = _breakpointObserver;
          this._parentSnackBar = _parentSnackBar;
          this._defaultConfig = _defaultConfig;
          /**
           * Reference to the current snack bar in the view *at this level* (in the Angular injector tree).
           * If there is a parent snack-bar service, all operations should delegate to that parent
           * via `_openedSnackBarRef`.
           */

          this._snackBarRefAtThisLevel = null;
          /** The component that should be rendered as the snack bar's simple component. */

          this.simpleSnackBarComponent = _SimpleSnackBar;
          /** The container component that attaches the provided template or component. */

          this.snackBarContainerComponent = _MatSnackBarContainer;
          /** The CSS class to apply for handset mode. */

          this.handsetCssClass = 'mat-snack-bar-handset';
        }
        /** Reference to the currently opened snackbar at *any* level. */


        _createClass(_MatSnackBar, [{
          key: "_openedSnackBarRef",
          get: function get() {
            var parent = this._parentSnackBar;
            return parent ? parent._openedSnackBarRef : this._snackBarRefAtThisLevel;
          },
          set: function set(value) {
            if (this._parentSnackBar) {
              this._parentSnackBar._openedSnackBarRef = value;
            } else {
              this._snackBarRefAtThisLevel = value;
            }
          }
          /**
           * Creates and dispatches a snack bar with a custom component for the content, removing any
           * currently opened snack bars.
           *
           * @param component Component to be instantiated.
           * @param config Extra configuration for the snack bar.
           */

        }, {
          key: "openFromComponent",
          value: function openFromComponent(component, config) {
            return this._attach(component, config);
          }
          /**
           * Creates and dispatches a snack bar with a custom template for the content, removing any
           * currently opened snack bars.
           *
           * @param template Template to be instantiated.
           * @param config Extra configuration for the snack bar.
           */

        }, {
          key: "openFromTemplate",
          value: function openFromTemplate(template, config) {
            return this._attach(template, config);
          }
          /**
           * Opens a snackbar with a message and an optional action.
           * @param message The message to show in the snackbar.
           * @param action The label for the snackbar action.
           * @param config Additional configuration options for the snackbar.
           */

        }, {
          key: "open",
          value: function open(message) {
            var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
            var config = arguments.length > 2 ? arguments[2] : undefined;

            var _config = Object.assign(Object.assign({}, this._defaultConfig), config); // Since the user doesn't have access to the component, we can
            // override the data to pass in our own message and action.


            _config.data = {
              message: message,
              action: action
            }; // Since the snack bar has `role="alert"`, we don't
            // want to announce the same message twice.

            if (_config.announcementMessage === message) {
              _config.announcementMessage = undefined;
            }

            return this.openFromComponent(this.simpleSnackBarComponent, _config);
          }
          /**
           * Dismisses the currently-visible snack bar.
           */

        }, {
          key: "dismiss",
          value: function dismiss() {
            if (this._openedSnackBarRef) {
              this._openedSnackBarRef.dismiss();
            }
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            // Only dismiss the snack bar at the current level on destroy.
            if (this._snackBarRefAtThisLevel) {
              this._snackBarRefAtThisLevel.dismiss();
            }
          }
          /**
           * Attaches the snack bar container component to the overlay.
           */

        }, {
          key: "_attachSnackBarContainer",
          value: function _attachSnackBarContainer(overlayRef, config) {
            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;

            var injector = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
              parent: userInjector || this._injector,
              providers: [{
                provide: _MatSnackBarConfig,
                useValue: config
              }]
            });

            var containerPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.ComponentPortal(this.snackBarContainerComponent, config.viewContainerRef, injector);
            var containerRef = overlayRef.attach(containerPortal);
            containerRef.instance.snackBarConfig = config;
            return containerRef.instance;
          }
          /**
           * Places a new component or a template as the content of the snack bar container.
           */

        }, {
          key: "_attach",
          value: function _attach(content, userConfig) {
            var _this6 = this;

            var config = Object.assign(Object.assign(Object.assign({}, new _MatSnackBarConfig()), this._defaultConfig), userConfig);

            var overlayRef = this._createOverlay(config);

            var container = this._attachSnackBarContainer(overlayRef, config);

            var snackBarRef = new _MatSnackBarRef(container, overlayRef);

            if (content instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef) {
              var portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.TemplatePortal(content, null, {
                $implicit: config.data,
                snackBarRef: snackBarRef
              });
              snackBarRef.instance = container.attachTemplatePortal(portal);
            } else {
              var injector = this._createInjector(config, snackBarRef);

              var _portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__.ComponentPortal(content, undefined, injector);

              var contentRef = container.attachComponentPortal(_portal); // We can't pass this via the injector, because the injector is created earlier.

              snackBarRef.instance = contentRef.instance;
            } // Subscribe to the breakpoint observer and attach the mat-snack-bar-handset class as
            // appropriate. This class is applied to the overlay element because the overlay must expand to
            // fill the width of the screen for full width snackbars.


            this._breakpointObserver.observe(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__.Breakpoints.HandsetPortrait).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.takeUntil)(overlayRef.detachments())).subscribe(function (state) {
              var classList = overlayRef.overlayElement.classList;
              state.matches ? classList.add(_this6.handsetCssClass) : classList.remove(_this6.handsetCssClass);
            });

            if (config.announcementMessage) {
              // Wait until the snack bar contents have been announced then deliver this message.
              container._onAnnounce.subscribe(function () {
                _this6._live.announce(config.announcementMessage, config.politeness);
              });
            }

            this._animateSnackBar(snackBarRef, config);

            this._openedSnackBarRef = snackBarRef;
            return this._openedSnackBarRef;
          }
          /** Animates the old snack bar out and the new one in. */

        }, {
          key: "_animateSnackBar",
          value: function _animateSnackBar(snackBarRef, config) {
            var _this7 = this;

            // When the snackbar is dismissed, clear the reference to it.
            snackBarRef.afterDismissed().subscribe(function () {
              // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.
              if (_this7._openedSnackBarRef == snackBarRef) {
                _this7._openedSnackBarRef = null;
              }

              if (config.announcementMessage) {
                _this7._live.clear();
              }
            });

            if (this._openedSnackBarRef) {
              // If a snack bar is already in view, dismiss it and enter the
              // new snack bar after exit animation is complete.
              this._openedSnackBarRef.afterDismissed().subscribe(function () {
                snackBarRef.containerInstance.enter();
              });

              this._openedSnackBarRef.dismiss();
            } else {
              // If no snack bar is in view, enter the new snack bar.
              snackBarRef.containerInstance.enter();
            } // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.


            if (config.duration && config.duration > 0) {
              snackBarRef.afterOpened().subscribe(function () {
                return snackBarRef._dismissAfter(config.duration);
              });
            }
          }
          /**
           * Creates a new overlay and places it in the correct location.
           * @param config The user-specified snack bar config.
           */

        }, {
          key: "_createOverlay",
          value: function _createOverlay(config) {
            var overlayConfig = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_8__.OverlayConfig();
            overlayConfig.direction = config.direction;

            var positionStrategy = this._overlay.position().global(); // Set horizontal position.


            var isRtl = config.direction === 'rtl';
            var isLeft = config.horizontalPosition === 'left' || config.horizontalPosition === 'start' && !isRtl || config.horizontalPosition === 'end' && isRtl;
            var isRight = !isLeft && config.horizontalPosition !== 'center';

            if (isLeft) {
              positionStrategy.left('0');
            } else if (isRight) {
              positionStrategy.right('0');
            } else {
              positionStrategy.centerHorizontally();
            } // Set horizontal position.


            if (config.verticalPosition === 'top') {
              positionStrategy.top('0');
            } else {
              positionStrategy.bottom('0');
            }

            overlayConfig.positionStrategy = positionStrategy;
            return this._overlay.create(overlayConfig);
          }
          /**
           * Creates an injector to be used inside of a snack bar component.
           * @param config Config that was used to create the snack bar.
           * @param snackBarRef Reference to the snack bar.
           */

        }, {
          key: "_createInjector",
          value: function _createInjector(config, snackBarRef) {
            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            return _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
              parent: userInjector || this._injector,
              providers: [{
                provide: _MatSnackBarRef,
                useValue: snackBarRef
              }, {
                provide: _MAT_SNACK_BAR_DATA,
                useValue: config.data
              }]
            });
          }
        }]);

        return _MatSnackBar;
      }();

      _MatSnackBar.ɵfac = function MatSnackBar_Factory(t) {
        return new (t || _MatSnackBar)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_8__.Overlay), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_12__.LiveAnnouncer), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__.BreakpointObserver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_MatSnackBar, 12), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_MAT_SNACK_BAR_DEFAULT_OPTIONS));
      };

      _MatSnackBar.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        factory: function MatSnackBar_Factory() {
          return new _MatSnackBar(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_8__.Overlay), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_12__.LiveAnnouncer), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.INJECTOR), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__.BreakpointObserver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_MatSnackBar, 12), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_MAT_SNACK_BAR_DEFAULT_OPTIONS));
        },
        token: _MatSnackBar,
        providedIn: _MatSnackBarModule
      });

      _MatSnackBar.ctorParameters = function () {
        return [{
          type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_8__.Overlay
        }, {
          type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_12__.LiveAnnouncer
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector
        }, {
          type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__.BreakpointObserver
        }, {
          type: _MatSnackBar,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
          }]
        }, {
          type: _MatSnackBarConfig,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_MAT_SNACK_BAR_DEFAULT_OPTIONS]
          }]
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_MatSnackBar, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
          args: [{
            providedIn: _MatSnackBarModule
          }]
        }], function () {
          return [{
            type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_8__.Overlay
          }, {
            type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_12__.LiveAnnouncer
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector
          }, {
            type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__.BreakpointObserver
          }, {
            type: _MatSnackBar,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
            }, {
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
            }]
          }, {
            type: _MatSnackBarConfig,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_MAT_SNACK_BAR_DEFAULT_OPTIONS]
            }]
          }];
        }, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */
      //# sourceMappingURL=snack-bar.js.map

      /***/

    }
  }]);
})();
//# sourceMappingURL=default-node_modules_angular_material___ivy_ngcc___fesm2015_snack-bar_js-es5.js.map