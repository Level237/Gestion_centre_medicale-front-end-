{"version":3,"sources":["../../src/gauge-defaults.service.ts","../../src/gauge.component.ts","../../src/gauge.module.ts"],"names":["this","dialStartAngle","dialEndAngle","dialRadius","min","max","showValue","gaugeClass","dialClass","valueDialClass","valueClass","animated","GaugeComponent","elm","defaults","gaugeCreated","EventEmitter","prototype","ngAfterViewInit","_this","options","label","value","color","Object","keys","forEach","optionKey","gauge","Gauge","nativeElement","emit","updateValue","ngOnChanges","changes","setValueAnimated","animationDuration","setValue","Component","args","selector","template","ElementRef","GaugeDefaults","Input","Output","USER_DEFAULTS","InjectionToken","defaultsFactory","userDefaults","assign","GaugeModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","NgModule","declarations","exports"],"mappings":"6bA6EA,WAIEA,KAAAC,eAAyB,IAKzBD,KAAAE,aAAuB,GAKvBF,KAAAG,WAAqB,GAKrBH,KAAAI,IAAc,EAKdJ,KAAAK,IAAc,IAedL,KAAAM,WAAqB,EAKrBN,KAAAO,WAAqB,QAKrBP,KAAAQ,UAAoB,OAKpBR,KAAAS,eAAyB,QAKzBT,KAAAU,WAAqB,aAUrBV,KAAAW,UAAoB,gBC9CpB,SAAAC,EAAoBC,EAAyBC,GAAzBd,KAAAa,IAAAA,EAAyBb,KAAAc,SAAAA,EAJnCd,KAAAe,aAA6C,IAAIC,EAAAA,oBAM3DJ,EAAAK,UAAAC,gBAAA,WAAA,IAAAC,EAAAnB,KACQoB,EAAwB,CAC5BnB,eAAgBD,KAAKC,eACrBC,aAAcF,KAAKE,aACnBC,WAAYH,KAAKG,WACjBC,IAAKJ,KAAKI,IACVC,IAAKL,KAAKK,IACVgB,MAAOrB,KAAKqB,MACZf,UAAWN,KAAKM,UAChBC,WAAYP,KAAKO,WACjBC,UAAWR,KAAKQ,UAChBC,eAAgBT,KAAKS,eACrBC,WAAYV,KAAKU,WACjBY,MAAOtB,KAAKsB,MACZC,MAAOvB,KAAKuB,OAGdC,OAAOC,KAAKzB,KAAKc,UAAUY,SAAQ,SAACC,QACA,IAAvBP,EAAQO,KACjBP,EAAQO,GAAaR,EAAKL,SAASa,OAIvCH,OAAOC,KAAKL,GAASM,SAAQ,SAACC,QACM,IAAvBP,EAAQO,WACVP,EAAQO,MAInB3B,KAAK4B,MAAQC,EAAAA,QAAM7B,KAAKa,IAAIiB,cAAeV,GAE3CpB,KAAKe,aAAagB,KAAK,CAAEH,MAAO5B,KAAK4B,QAErC5B,KAAKgC,eAGPpB,EAAAK,UAAAgB,YAAA,SAAYC,GACNA,EAAe,OACjBlC,KAAKgC,eAIDpB,EAAAK,UAAAe,YAAA,WACFhC,KAAK4B,QACH5B,KAAKW,SACPX,KAAK4B,MAAMO,iBAAiBnC,KAAKsB,MAAOtB,KAAKoC,mBAE7CpC,KAAK4B,MAAMS,SAASrC,KAAKsB,kCAxIhCgB,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,YACVC,SAAU,gDAbVC,EAAAA,kBASOC,6CAUNC,EAAAA,4BAKAA,EAAAA,0BAKAA,EAAAA,mBAKAA,EAAAA,mBAKAA,EAAAA,qBAKAA,EAAAA,qBAKAA,EAAAA,yBAKAA,EAAAA,0BAKAA,EAAAA,yBAKAA,EAAAA,8BAKAA,EAAAA,0BAKAA,EAAAA,qBAKAA,EAAAA,wBAKAA,EAAAA,iCAKAA,EAAAA,4BAKAC,EAAAA,cC5FUC,EAAwC,IAAIC,EAAAA,eACvD,2BAGcC,EAAgBC,GAC9B,IAAMnC,EAA0B,IAAI6B,EAEpC,OADAnB,OAAO0B,OAAOpC,EAAUmC,GACjBnC,mBAOT,SAAAqC,YACSA,EAAAC,QAAP,SACEH,GAEA,YAFA,IAAAA,IAAAA,EAAA,IAEO,CACLI,SAAUF,EACVG,UAAW,CACT,CACEC,QAAST,EACTU,SAAUP,GAEZ,CACEM,QAASZ,EACTc,WAAYT,EACZU,KAAM,CAACZ,gCAlBhBa,EAAAA,SAAQpB,KAAA,CAAC,CACRqB,aAAc,CAAChD,GACfiD,QAAS,CAACjD","sourcesContent":["export interface GaugeOptions {\n  /**\n   * The angle in degrees to start the dial\n   */\n  dialStartAngle?: number;\n\n  /**\n   * The angle in degrees to end the dial. This MUST be less than dialStartAngle\n   */\n  dialEndAngle?: number;\n\n  /**\n   * The radius of the gauge\n   */\n  dialRadius?: number;\n\n  /**\n   * The minumum value for the gauge\n   */\n  min?: number;\n\n  /**\n   * The maximum value for the gauge\n   */\n  max?: number;\n\n  /**\n   * Function that returns a string label that will be rendered in the center. This function will be passed the current value\n   */\n  label?: (value: number) => string;\n\n  /**\n   * Function that returns a string color value for the gauge''s fill (value dial)\n   */\n  color?: (value: number) => string;\n\n  /**\n   * Whether to show the value at the center of the gauge\n   */\n  showValue?: boolean;\n\n  /**\n   * The CSS class of the gauge\n   */\n  gaugeClass?: string;\n\n  /**\n   * The CSS class of the gauge's dial\n   */\n  dialClass?: string;\n\n  /**\n   * The CSS class of the gauge's fill (value dial)\n   */\n  valueDialClass?: string;\n\n  /**\n   * \tThe CSS class of the gauge's text\n   */\n  valueClass?: string;\n\n  /**\n   * The value of the gauge\n   */\n  value?: number;\n\n  /**\n   * Whether to animate changing the gauge\n   */\n  animated?: boolean;\n\n  /**\n   * Animation duration in seconds\n   */\n  animationDuration?: number;\n}\n\nexport class GaugeDefaults implements GaugeOptions {\n  /**\n   * The angle in degrees to start the dial\n   */\n  dialStartAngle: number = 135;\n\n  /**\n   * The angle in degrees to end the dial. This MUST be less than dialStartAngle\n   */\n  dialEndAngle: number = 45;\n\n  /**\n   * The radius of the gauge\n   */\n  dialRadius: number = 40;\n\n  /**\n   * The minimum value for the gauge\n   */\n  min: number = 0;\n\n  /**\n   * The maximum value for the gauge\n   */\n  max: number = 100;\n\n  /**\n   * Function that returns a string label that will be rendered in the center. This function will be passed the current value\n   */\n  label: (value: number) => string;\n\n  /**\n   * Function that returns a string color value for the gauge''s fill (value dial)\n   */\n  color: (value: number) => string;\n\n  /**\n   * Whether to show the value at the center of the gauge\n   */\n  showValue: boolean = true;\n\n  /**\n   * The CSS class of the gauge\n   */\n  gaugeClass: string = 'gauge';\n\n  /**\n   * The CSS class of the gauge's dial\n   */\n  dialClass: string = 'dial';\n\n  /**\n   * The CSS class of the gauge's fill (value dial)\n   */\n  valueDialClass: string = 'value';\n\n  /**\n   * \tThe CSS class of the gauge's text\n   */\n  valueClass: string = 'value-text';\n\n  /**\n   * The value of the gauge\n   */\n  value: number;\n\n  /**\n   * Whether to animate changing the gauge\n   */\n  animated: boolean = false;\n\n  /**\n   * Animation duration in seconds\n   */\n  animationDuration: number;\n}\n","import {\n  Component,\n  ElementRef,\n  Input,\n  Output,\n  EventEmitter,\n  AfterViewInit,\n  OnChanges,\n  SimpleChanges,\n} from '@angular/core';\nimport Gauge from 'svg-gauge';\nimport { GaugeDefaults, GaugeOptions } from './gauge-defaults.service';\n\n@Component({\n  selector: 'mwl-gauge',\n  template: '',\n})\nexport class GaugeComponent implements AfterViewInit, OnChanges, GaugeOptions {\n  /**\n   * The angle in degrees to start the dial\n   */\n  @Input() dialStartAngle: number;\n\n  /**\n   * The angle in degrees to end the dial. This MUST be less than dialStartAngle\n   */\n  @Input() dialEndAngle: number;\n\n  /**\n   * The radius of the gauge\n   */\n  @Input() dialRadius: number;\n\n  /**\n   * The minimum value for the gauge\n   */\n  @Input() min: number;\n\n  /**\n   * The maximum value for the gauge\n   */\n  @Input() max: number;\n\n  /**\n   * Function that returns a string label that will be rendered in the center. This function will be passed the current value\n   */\n  @Input() label: (value: number) => string;\n\n  /**\n   * Function that returns a string color value for the gauge''s fill (value dial)\n   */\n  @Input() color: (value: number) => string;\n\n  /**\n   * Whether to show the value at the center of the gauge\n   */\n  @Input() showValue: boolean;\n\n  /**\n   * The CSS class of the gauge\n   */\n  @Input() gaugeClass: string;\n\n  /**\n   * The CSS class of the gauge's dial\n   */\n  @Input() dialClass: string;\n\n  /**\n   * The CSS class of the gauge's fill (value dial)\n   */\n  @Input() valueDialClass: string;\n\n  /**\n   * \tThe CSS class of the gauge's text\n   */\n  @Input() valueClass: string;\n\n  /**\n   * The value of the gauge\n   */\n  @Input() value: number;\n\n  /**\n   * Whether to animate changing the gauge\n   */\n  @Input() animated: boolean;\n\n  /**\n   * Animation duration in seconds\n   */\n  @Input() animationDuration: number;\n\n  /**\n   * Called when the gauge is created\n   */\n  @Output() gaugeCreated: EventEmitter<{ gauge: any }> = new EventEmitter();\n\n  private gauge: any;\n\n  constructor(private elm: ElementRef, private defaults: GaugeDefaults) {}\n\n  ngAfterViewInit(): void {\n    const options: GaugeOptions = {\n      dialStartAngle: this.dialStartAngle,\n      dialEndAngle: this.dialEndAngle,\n      dialRadius: this.dialRadius,\n      min: this.min,\n      max: this.max,\n      label: this.label,\n      showValue: this.showValue,\n      gaugeClass: this.gaugeClass,\n      dialClass: this.dialClass,\n      valueDialClass: this.valueDialClass,\n      valueClass: this.valueClass,\n      value: this.value,\n      color: this.color,\n    };\n\n    Object.keys(this.defaults).forEach((optionKey) => {\n      if (typeof options[optionKey] === 'undefined') {\n        options[optionKey] = this.defaults[optionKey];\n      }\n    });\n\n    Object.keys(options).forEach((optionKey) => {\n      if (typeof options[optionKey] === 'undefined') {\n        delete options[optionKey];\n      }\n    });\n\n    this.gauge = Gauge(this.elm.nativeElement, options);\n\n    this.gaugeCreated.emit({ gauge: this.gauge });\n\n    this.updateValue();\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['value']) {\n      this.updateValue();\n    }\n  }\n\n  private updateValue(): void {\n    if (this.gauge) {\n      if (this.animated) {\n        this.gauge.setValueAnimated(this.value, this.animationDuration);\n      } else {\n        this.gauge.setValue(this.value);\n      }\n    }\n  }\n}\n","import { NgModule, InjectionToken, ModuleWithProviders } from '@angular/core';\nimport { GaugeComponent } from './gauge.component';\nimport { GaugeDefaults, GaugeOptions } from './gauge-defaults.service';\n\nexport const USER_DEFAULTS: InjectionToken<string> = new InjectionToken(\n  'gauge defaults'\n);\n\nexport function defaultsFactory(userDefaults: GaugeOptions): GaugeDefaults {\n  const defaults: GaugeDefaults = new GaugeDefaults();\n  Object.assign(defaults, userDefaults);\n  return defaults;\n}\n\n@NgModule({\n  declarations: [GaugeComponent],\n  exports: [GaugeComponent],\n})\nexport class GaugeModule {\n  static forRoot(\n    userDefaults: GaugeOptions = {}\n  ): ModuleWithProviders<GaugeModule> {\n    return {\n      ngModule: GaugeModule,\n      providers: [\n        {\n          provide: USER_DEFAULTS,\n          useValue: userDefaults,\n        },\n        {\n          provide: GaugeDefaults,\n          useFactory: defaultsFactory,\n          deps: [USER_DEFAULTS],\n        },\n      ],\n    };\n  }\n}\n"]}